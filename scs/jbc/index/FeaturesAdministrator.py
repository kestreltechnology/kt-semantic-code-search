# ------------------------------------------------------------------------------
# Python API to access CodeHawk Java Analyzer analysis results
# Author: Henny Sipma
# ------------------------------------------------------------------------------
# The MIT License (MIT)
#
# Copyright (c) 2016-2018 Kestrel Technology LLC
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ------------------------------------------------------------------------------

import hashlib
import os
import subprocess
import zipfile

import scs.jbc.util.fileutil as UF

from scs.jbc.features.ClassFeatures import ClassFeatures

from scs.jbc.index.JarManifest import JarManifest
from scs.jbc.index.ClassMd5Index import ClassMd5Index
from scs.jbc.index.JarMd5Index import JarMd5Index
from scs.jbc.index.JarMd5Xref import JarMd5Xref
from scs.jbc.index.JarNames import JarNames
from scs.jbc.index.ClassNameIndex import ClassNameIndex
from scs.jbc.index.ClassMd5Xref import ClassMd5Xref
from scs.jbc.index.PackageIndex import PackageIndex


"""
Controls the inclusion and retrieval of pre-features as generated by CodeHawk.

It maintains the following mappings in the docindex directory of the features
directory:
- jarmanifest.json       : jarmd5ix -> pckix -> classmd5ix list
- jarmd5s.json           : jarmd5 -> jarmd5ix
- packageindex.json      : package name -> pckix
- classmd5s.json         : classmd5 -> classmd5ix
- classnames.json        : class name -> cnix
- classmd5xref.json      : classmd5ix -> (pckix, cnix)
"""

class FeaturesAdministrator():

    def __init__(self,featurespath):
        self.featurespath = featurespath
        self.jarmanifest = JarManifest(featurespath)
        self.jarmd5index = JarMd5Index(featurespath)
        self.packageindex = PackageIndex(featurespath)
        self.classmd5index = ClassMd5Index(featurespath)
        self.classnameindex = ClassNameIndex(featurespath)
        self.classmd5xref = ClassMd5Xref(featurespath)

    def generate_features(self,jarpath,cmd):
        featurespath = self.featurespath
        for root, dirs, files in os.walk(jarpath):
            for name in files:
                if name.endswith('.jar'):
                    fname = os.path.join(root,name)
                    if self.contains_class_files(fname):
                        jmd5 = self.get_jarmd5(fname)
                        jmd5ix = self.jarmd5index.add_jmd5(jmd5)
                        if self.jarmanifest.has_jar(jmd5ix):
                            self.jarmanifest.add_file(jmd5ix,name)                    
                            continue
                        self.jarmanifest.add_file(jmd5ix,name)
                        self.generate_jar_features(cmd,fname,featurespath)
                        jarpackages = self.get_jar_packages(fname,featurespath)
                        for package in jarpackages:
                            pckix = self.packageindex.add_package(package)
                            for (cmd5,classname) in jarpackages[package]:
                                cmd5ix = self.classmd5index.add_cmd5(cmd5)
                                cnix = self.classnameindex.add_classname(classname)
                                self.classmd5xref.add_xref(cmd5ix,pckix,cnix)
                                self.jarmanifest.add_xref(jmd5ix,pckix,cmd5ix)
        self.classmd5index.save()
        self.jarmd5index.save()
        self.packageindex.save()
        self.classnameindex.save()
        self.classmd5xref.save()
        self.jarmanifest.save()

    def generate_jar_features(self,cmd,jarfilename,featurespath):
        cmd = [ cmd, '-o', featurespath, jarfilename ]
        return subprocess.call(cmd, stderr=subprocess.STDOUT)

    def get_jarmd5(self,jarfile):
        return hashlib.md5(open(jarfile,'rb').read()).hexdigest()

    def contains_class_files(self,jarfilename):
        try:
            jarfile = zipfile.ZipFile(jarfilename,'r')
            for info in jarfile.infolist():
                if info.filename.endswith('class'):
                    return True
            else:
                print(jarfilename + ' does not contain any class files. Skip.')
                return False
        except zipfile.BadZipfile:
            print(jarfilename + ' appears to be corrupted. Skip.')
            return False

    def get_jar_packages(self,jarfilename,featurespath):
        packages = {}    # pckname -> (cmd5, classname) list
        filenames = []
        try:
            jarfile = zipfile.ZipFile(jarfilename,'r')
            for info in jarfile.infolist():
                filenames.append(info.filename)
            for f in filenames:
                if f.endswith('.class'):
                    zfile = jarfile.read(f)
                    cmd5 = hashlib.md5(zfile).hexdigest()
                    filename = UF.get_cmd5_filename(featurespath,cmd5)
                    if os.path.isfile(filename):
                        xclass = UF.get_xnode(filename,'class')
                        packagename = xclass.get('package')
                        if not packagename in packages:
                            packages[packagename] = []
                        packages[packagename].append((cmd5,xclass.get('name')))
        except zipfile.BadZipfile:
            print(jarfile + ' appears to be corrupted. Skip.')
        return packages
                    

    """Incorporates features from the classfiles in featurespath into an index
    The index may be a new index or an existing index, in which case the features
    are integrated with the existing features.
    arguments:
    -indexadmin: index administrator
    -classpredicate: ClassPredicate with requirement code elements (filter)
    -recorder: FeaturesRecorder that specifies which features to record (visitor)

    fjmd5ix: jar-md5-index on the features side
    ijmd5ix: jar-md5-index on the index side
    fcmd5ix: class-md5-index on the features side
    icmd5ix: class-md5-index on the index side
    """
    def index_features(self,indexadmin,classpredicate,recorder):
        excluded = 0
        for fjmd5ix in self.jarmanifest.xref:
            jmd5 = self.jarmd5index.get_jmd5(fjmd5ix)
            if indexadmin.has_jar(jmd5):
                continue
            jarfiles = self.jarmanifest.get_files(fjmd5ix)
            # add jar to the index
            ijmd5ix = indexadmin.jarmd5index.add_jmd5(jmd5)
            indexadmin.jarnames.add_jar(ijmd5ix,jarfiles)

            for fcmd5ix in self.jarmanifest.get_cmd5ixs(fjmd5ix):
                cmd5 = self.classmd5index.get_cmd5(fcmd5ix)
                if indexadmin.has_cmd5(cmd5):
                    # add class to the jar cross reference
                    icmd5ix = indexadmin.get_cmd5ix(cmd5)
                    indexadmin.jmd5xref.add_xref(ijmd5ix,icmd5ix)
                    continue
                xclass = UF.load_features_file(self.featurespath,cmd5)
                cfeatures = ClassFeatures(xclass)
                if classpredicate.satisfies(cfeatures):
                    # add class to the index
                    icmd5ix = indexadmin.classmd5index.add_cmd5(cmd5)
                    indexadmin.jmd5xref.add_xref(ijmd5ix,icmd5ix)
                    indexadmin.add_class_features(cfeatures,ijmd5ix,recorder)
                else:
                    excluded += 1
        indexadmin.save_features()
        indexadmin.jar_features()
        return excluded
                        
            
